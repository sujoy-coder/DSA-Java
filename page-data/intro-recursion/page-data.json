{"componentChunkName":"component---src-templates-lesson-template-js","path":"/intro-recursion","result":{"data":{"markdownRemark":{"html":"<p>Recursion is a technique that leads to elegant solutions to problems that are difficult to solve using simple iteration(loops). In some cases, it enables\nyou to develop a natural, straightforward, simple solution to an otherwise difficult problem.</p>\n<blockquote>\n<p>Recursion in Computer Science is a method where the solution to a problem depends on the solution to smaller instances of the same problem.</p>\n</blockquote>\n<p>This lesson introduces the concepts and techniques of recursive programming and illustrates with examples of how to <strong>“think recursively”</strong>. Let's understand this by a simple example:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">    <span class=\"token class-name\">Calculate</span> factorial of a number by using recursion</code></pre></div>\n<p>Now, How do you find <code class=\"language-text\">n!</code> of a given number?</p>\n<ul>\n<li>To find <code class=\"language-text\">1!</code> is easy, because you know that <code class=\"language-text\">0!</code> is 1, and 1! is 1 × 0!.</li>\n<li>Assuming that you know <code class=\"language-text\">(n - 1)!</code>, you can obtain n! immediately by using <code class=\"language-text\">n × (n - 1)!</code>. Thus, the problem of computing n! is reduced to computing (n - 1)!. When computing <code class=\"language-text\">(n - 1)!</code>, you can apply the same idea recursively until n is reduced to 0.</li>\n<li>Let factorial(n) be the method for computing n!. If you call the method with n = 0, it immediately returns the result. The method knows how to solve the simplest case, which is referred to as the <strong>base case</strong> or the stopping condition.</li>\n<li>If you call the method with n > 0, it reduces the problem into a subproblem for computing the factorial of n - 1.</li>\n<li>The subproblem is essentially the same as the original problem, but it is simpler or smaller. Because the sub-problem has the same property as the original problem, you can call the method with a different argument, which is referred to as a recursive call.</li>\n<li>The recursive algorithm for computing factorial(n) can be simply described as follows:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> n <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>A recursive call can result in many more recursive calls, because the method keeps on dividing a subproblem into new subproblems. For a recursive method to terminate, the problem must eventually be reduced to a stopping case, at which point the method returns a result to its caller. The caller then performs a computation and returns the result to its own caller. This process continues until the result is passed back to the original caller. The original problem\ncan now be solved by multiplying <code class=\"language-text\">n</code> by the result of <strong>factorial(n - 1)</strong>.</p>","frontmatter":{"path":"/intro-recursion","title":"Intro to Recursion","order":"8A","section":"Recursion"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"order":"4A","path":"/arrays","title":"Introduction to Arrays"}}},{"node":{"frontmatter":{"order":"4B","path":"/arraylist","title":"ArrayList In Java"}}},{"node":{"frontmatter":{"order":"24A","path":"/assignment","title":"Assignments"}}},{"node":{"frontmatter":{"order":"9E","path":"/backtrack-maze","title":"Maze Problems"}}},{"node":{"frontmatter":{"order":"9D","path":"/backtrack-nknight","title":"N Knights"}}},{"node":{"frontmatter":{"order":"9B","path":"/backtrack-sudoku","title":"Sudoku Solver"}}},{"node":{"frontmatter":{"order":"9A","path":"/backtracking","title":"Introduction to Backtracking"}}},{"node":{"frontmatter":{"order":"5B","path":"/binarysearch","title":"Binary Search"}}},{"node":{"frontmatter":{"order":"4D","path":"/bmmv-algorithm","title":"Boyer-Moore Majority Voting Algorithm"}}},{"node":{"frontmatter":{"order":"9C","path":"/backtrack-nqueen","title":"N Queens"}}},{"node":{"frontmatter":{"order":"5C","path":"/bubblesort","title":"Bubble Sort"}}},{"node":{"frontmatter":{"order":"10B","path":"/bitwise-operator","title":"Complete Bitwise Operators"}}},{"node":{"frontmatter":{"order":"5H","path":"/cyclesort","title":"Cyclic Sort"}}},{"node":{"frontmatter":{"order":"5F","path":"/countsort","title":"Count Sort"}}},{"node":{"frontmatter":{"order":"2C","path":"/firstjavaprogram","title":"First Java Program"}}},{"node":{"frontmatter":{"order":"3A","path":"/dataTypes","title":"Learn Data Types"}}},{"node":{"frontmatter":{"order":"8B","path":"/flow-of-recursion","title":"Flow of Recursion"}}},{"node":{"frontmatter":{"order":"2A","path":"/flowchart","title":"Flowchart & Pseudocode"}}},{"node":{"frontmatter":{"order":"20A","path":"/greedy","title":"Introduction to Greedy Algorithms"}}},{"node":{"frontmatter":{"order":"3F","path":"/functions","title":"Function & Scope"}}},{"node":{"frontmatter":{"order":"15A","path":"/intro-binarytree","title":"Intro to Binary Tree"}}},{"node":{"frontmatter":{"order":"5E","path":"/insertion","title":"Insertion Sort"}}},{"node":{"frontmatter":{"order":"16A","path":"/intro-bst","title":"Intro to BST"}}},{"node":{"frontmatter":{"order":"7A","path":"/intro-complexity","title":"Complexity Analysis"}}},{"node":{"frontmatter":{"order":"19A","path":"/intro-dp","title":"Introduction to DP"}}},{"node":{"frontmatter":{"order":"12A","path":"/intro-ds","title":"Introduction to Data Structures"}}},{"node":{"frontmatter":{"order":"22A","path":"/intro-graphs","title":"Introduction to Graphs"}}},{"node":{"frontmatter":{"order":"18A","path":"/intro-hashmap","title":"Introduction to Hashmap"}}},{"node":{"frontmatter":{"order":"17A","path":"/intro-heap","title":"Introduction to Heaps"}}},{"node":{"frontmatter":{"order":"12B","path":"/intro-linkedlist","title":"Introduction to Linked List"}}},{"node":{"frontmatter":{"order":"10A","path":"/intro-maths","title":"Introduction to Maths in DSA"}}},{"node":{"frontmatter":{"order":"11A","path":"/intro-oop","title":"Introduction"}}},{"node":{"frontmatter":{"order":"21A","path":"/intro-priorityqueues","title":"Introduction to Priority Queues"}}},{"node":{"frontmatter":{"order":"1B","path":"/intro-programming","title":"Intro to Programming"}}},{"node":{"frontmatter":{"order":"8A","path":"/intro-recursion","title":"Intro to Recursion"}}},{"node":{"frontmatter":{"order":"13A","path":"/intro-stacks","title":"Intro to Stack"}}},{"node":{"frontmatter":{"order":"6A","path":"/intro-string","title":"Intro to Strings"}}},{"node":{"frontmatter":{"order":"14A","path":"/intro-trees","title":"Intro to Trees"}}},{"node":{"frontmatter":{"order":"23A","path":"/intro-tries","title":"Introduction to Tries"}}},{"node":{"frontmatter":{"order":"1A","path":"/introduction","title":"Welcome"}}},{"node":{"frontmatter":{"order":"2B","path":"/java-setup","title":"Java Development Setup"}}},{"node":{"frontmatter":{"order":"3C","path":"/io-conditionals","title":"Input/Output & Conditionals"}}},{"node":{"frontmatter":{"order":"3E","path":"/jumps","title":"Jumps Statements"}}},{"node":{"frontmatter":{"order":"3D","path":"/loops","title":"Loops In Java"}}},{"node":{"frontmatter":{"order":"8E","path":"/mergesort","title":"Merge Sort"}}},{"node":{"frontmatter":{"order":"5A","path":"/linearsearch","title":"Linear Search"}}},{"node":{"frontmatter":{"order":"10C","path":"/num-one","title":"Number Theory Part-A"}}},{"node":{"frontmatter":{"order":"10E","path":"/num-three","title":"Number Theory Part-C"}}},{"node":{"frontmatter":{"order":"10D","path":"/num-two","title":"Number Theory Part-B"}}},{"node":{"frontmatter":{"order":"3B","path":"/operators","title":"Operators in Java"}}},{"node":{"frontmatter":{"order":"5I","path":"/practise-question","title":"Practise Questions"}}},{"node":{"frontmatter":{"order":"4C","path":"/print-patterns","title":"Printing Patterns"}}},{"node":{"frontmatter":{"order":"11C","path":"/properties","title":"Properties of OOP"}}},{"node":{"frontmatter":{"order":"8F","path":"/quicksort","title":"Quick Sort"}}},{"node":{"frontmatter":{"order":"5G","path":"/radixsort","title":"Radix Sort"}}},{"node":{"frontmatter":{"order":"7D","path":"/recurrence","title":"Recurrence Relations"}}},{"node":{"frontmatter":{"order":"8C","path":"/recursion-arrays","title":"Recursion & Array"}}},{"node":{"frontmatter":{"order":"8G","path":"/recursion-practise","title":"Standard Practise Questions"}}},{"node":{"frontmatter":{"order":"8D","path":"/recursion-string","title":"Recursion & Strings"}}},{"node":{"frontmatter":{"order":"5D","path":"/selectionsort","title":"Selection Sort"}}},{"node":{"frontmatter":{"order":"7C","path":"/space-complexity","title":"Space Complexity"}}},{"node":{"frontmatter":{"order":"6B","path":"/string-builder","title":"StringBuilder in Java"}}},{"node":{"frontmatter":{"order":"4E","path":"/subarrays","title":"Subarrays"}}},{"node":{"frontmatter":{"order":"11B","path":"/this-constructor","title":"this Keyword & Constructor"}}},{"node":{"frontmatter":{"order":"7B","path":"/time-complexity","title":"Time Complexity"}}}]}},"pageContext":{}},"staticQueryHashes":["137611351"]}